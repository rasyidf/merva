// Import necessary modules with proper naming
import * as path from 'node:path';
import fsExtra from 'fs-extra';
import { $ } from 'execa';
import { glob } from 'glob';
import { parse } from 'node-html-parser';
import { program } from 'commander';

// Configure commander for command-line options
program
	.name('npm run build:icons --')
	.description('Builds SVG icons into a single SVG sprite and TypeScript type file')
	.version('0.1.0');

// Define command-line options
program
	.option('--log <level>', 'Set log level (verbose or silent)', 'verbose')
	.option('--input <dir>', 'Set input directory', 'utils/svg-icons')
	.option('--output <dir>', 'Set output directory', 'src/assets/icons')
	.option('--sprite <file>', 'Set sprite file', 'src/assets/icons/sprite.svg')
	.option('--types <file>', 'Set types file', 'src/assets/icons/name.d.ts');

program.parse(process.argv);

// Constants for file paths
const options = program.opts();
const inputDir = path.resolve(process.cwd(), options.input);
const outputDir = path.resolve(process.cwd(), options.output);
const spriteFilepath = path.resolve(process.cwd(), options.sprite);
const typeOutputFilepath = path.resolve(process.cwd(), options.types);

// Ensure input directory exists
if (!fsExtra.existsSync(inputDir)) {
	console.error(`Error: Input directory does not exist: ${inputDir}`);
	process.exit(1);
}

// Ensure output directory exists
fsExtra.ensureDirSync(outputDir);

// Fetch SVG files and sort them
const files = glob.sync('**/*.svg', { cwd: inputDir }).sort((a, b) => a.localeCompare(b));

// Check for verbose logging
const shouldVerboseLog = options.log === 'verbose';
const logVerbose = shouldVerboseLog ? console.log : () => { };

// Main function to generate icon files
async function generateIconFiles(): Promise<void> {
	// Read existing sprite and types
	const currentSprite = fsExtra.readFileSync(spriteFilepath, 'utf8').toString();
	const currentTypes = fsExtra.readFileSync(typeOutputFilepath, 'utf8').toString();

	// Map file names to icon names
	const iconNames = files.map(iconName);

	// Check if sprite and types are up to date
	const [isSpriteChanged, isTypesChanged] = await Promise.all([
		!iconNames.every((name) => currentSprite.includes(`id=${name}`)),
		!iconNames.every((name) => currentTypes.includes(`"${name}"`)),
	]);

	// If up to date, log and return
	if (!isSpriteChanged && !isTypesChanged) {
		logVerbose(`Icons are up to date`);
		return;
	}

	logVerbose(`Generating sprite for ${path.relative(process.cwd(), inputDir)}`);

	// Generate SVG sprite
	const spriteChanged = await generateSvgSprite({ files, inputDir, outputPath: spriteFilepath });


	logVerbose(`Saved to ${path.relative(process.cwd(), spriteFilepath)}`);

	// Stringify icon names for TypeScript type
	const stringifiedIconNames = iconNames.map((name) => JSON.stringify(name));

	// Create TypeScript type file content
	const typeOutputContent = `// This file is generated by npm run build:icons\n\nexport type IconName =\n  | ${stringifiedIconNames.join('\n  | ')};
`;

	// Generate or update TypeScript type file
	const typesChanged = await writeIfChanged(typeOutputFilepath, typeOutputContent);

	logVerbose(`Manifest saved to ${path.relative(process.cwd(), typeOutputFilepath)}`);

	// Update or create README file
	const readmeChanged = await writeIfChanged(
		path.join(outputDir, 'README.md'),
		"# Icons\n\nThis directory contains SVG icons that are used by the app.\n\nEverything in this directory is generated by \`npm run build:icons\`.\n",
	);

	// Log if any changes were made
	if (spriteChanged || typesChanged || readmeChanged) {
		console.log(`Generated ${files.length} icons`);
	} else {
		console.log("Icons are up to date");
	}
}

// Function to transform file name to icon name
function iconName(file: string): string {
	return file.replace(/\.svg$/, '');
}

// Function to generate a single SVG file that contains all the icons
async function generateSvgSprite({
	files,
	inputDir,
	outputPath,
}: {
	files: string[];
	inputDir: string;
	outputPath: string;
}): Promise<boolean> {
	// Map files to symbols in parallel
	const symbols = await Promise.all(
		files.map(async (file) => {
			const input = fsExtra.readFileSync(path.join(inputDir, file), 'utf8').toString();
			const root = parse(input);

			const svg = root.querySelector('svg');
			if (!svg) throw new Error(`‚ùå No SVG element found in file: ${file}`);

			// Modify SVG attributes for symbol
			svg.tagName = 'symbol';
			svg.setAttribute('id', iconName(file));
			svg.removeAttribute('xmlns');
			svg.removeAttribute('xmlns:xlink');
			svg.removeAttribute('version');
			svg.removeAttribute('width');
			svg.removeAttribute('height');
			// Return string representation of symbol 
			return svg.toString().trim().replace(/\s\s+/g, ' ');
		}),
	);

	// Generate final output
	const output = [
		`<?xml version="1.0" encoding="UTF-8"?>`,
		`<!-- This file is generated by icon-builder -->`,
		`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
		`<defs>`,
		...symbols,
		`</defs>`,
		`</svg>`,
		'',
	].join('\n');

	// Write to file and return whether it changed
	return writeIfChanged(outputPath, output);
}

// Function to write content to a file if it changed
async function writeIfChanged(path: string, newContent: string): Promise<boolean> {
	const filepath = path.trim();
	if (!filepath) throw new Error('No filepath specified');
	const currentContent = fsExtra.readFileSync(filepath, 'utf8').toString();

	// If content is the same, return false
	if (currentContent === newContent) return false;

	// Write new content to file
	fsExtra.writeFileSync(filepath, newContent, 'utf8');

	// Check if file is a TypeScript file and format it
	if (filepath.endsWith('.ts')) $`biome format --write ${filepath}`;
	if (filepath.endsWith('.svg')) $`biome format --write ${filepath}`;

	// Return true indicating the file has changed
	return true;
}

// Call the main function
generateIconFiles();
